<html> 
  <head>
    <title>The Duck Game</title> 
  </head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <script src="/game.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(600, 600); 
      frameRate(30);
        
   /**
 * @how
 * theres a whole page bro, go read that
 *
 * @Credit
 * The Creator - @ToeKnee-top (me)
 *
 **/

// Declare global variables
var scene;
var cam;
var clicked;
var keys = [];
var dirts = [];
var ducks;
var carrott;
var pankakes = [];
var jurassic_grassusses = [];
var intro_timer;
var scene2b;
var shake;
var shake_time;

void setup() {
  size(600, 600);
  rectMode(CENTER);
  textFont(createFont("Courier"));
  textAlign(CENTER, CENTER);
  
  scene = "menu";
  cam = new PVector(0, 0);
  clicked = false;
  shake = 0;
  shake_time = 0;
  intro_timer = 1000;
  scene2b = "menu";

  // initialize ducks
  ducks = new Ducks();
  // initialize carrot
  carrott = new Carrot();
  // generate grass
  for (int i=0; i<100; i++) {
    jurassic_grassusses.push(new Grass());
  }
  // remove grass close to center
  for (int i=jurassic_grassusses.size()-1; i>=0; i--) {
    if (dist(jurassic_grassusses.get(i).x, jurassic_grassusses.get(i).y, 0, 0) < 300) {
      jurassic_grassusses.remove(i);
    }
  }
}

void draw() {
  intro_timer += 2;
  switch(scene) {
    case "game": game(); break;
    case "menu": menu(); break;
    case "how": how(); break;
  }

  if (intro_timer < 420) {
    pushMatrix();
    translate(300, 300);
    for (int i=0; i<14; i++) {
      rotate(radians(28));
      ducklol(0, 350 + sin(intro_timer*0.02)*300, 0, 500);
    }
    ducklol(0, 350 + sin(intro_timer*0.02)*300, 0, 1000);
    popMatrix();
    if (intro_timer == 270) {
      scene = scene2b;
    }
  }
  clicked = false;
}

// Mouse click sets clicked flag
void mouseClicked() {
  clicked = true;
}

// Key pressed and released
void keyPressed() {
  if (keyCode >= 0 && keyCode < 256) {
    keys[keyCode] = true;
  }
}
void keyReleased() {
  if (keyCode >= 0 && keyCode < 256) {
    keys[keyCode] = false;
  }
}

// Classes for various entities

class Grass {
  float x, y;
  Grass() {
    x = random(-1000, 1000);
    y = random(-1000, 1000);
  }
  void display() {
    pushMatrix();
    translate(x, y);
    strokeWeight(2);
    stroke(0);
    fill(153, 199, 166);
    beginShape();
    vertex(-22, 2);
    bezierVertex(-22, 0, -24, -9, -33, -14);
    bezierVertex(-33, -14, -24, -14, -20, -8);
    bezierVertex(-20, -8, -20, -14, -25, -23);
    bezierVertex(-25, -23, -19, -19, -16, -13);
    bezierVertex(-16, -13, -14, -18, -16, -29);
    bezierVertex(-10, -18, -11, -17, -9, -10);
    bezierVertex(-9, -10, -9, -14, -3, -21);
    bezierVertex(-3, -21, -4, -12, -2, -6);
    bezierVertex(-2, -6, -2, -18, 8, -26);
    bezierVertex(8, -26, 2, -13, 5, -4);
    bezierVertex(5, -4, 5, -8, 8, -16);
    bezierVertex(8, -16, 8, -9, 12, -4);
    bezierVertex(12, -4, 12, -10, 17, -20);
    bezierVertex(17, -20, 17, -9, 19, -3);
    bezierVertex(19, -3, 19, -8, 27, -15);
    bezierVertex(27, -15, 22, -4, 23, 2);
    endShape();
    popMatrix();
  }
}

class Ducks {
  float x, y, d, speed;
  float r1, r2, r3, r4, r5, r6, r7;
  boolean walking, U, D, R, L;
  int pancakes;
  float stamina;

  Ducks() {
    x=0; y=150; d=-49; speed=2;
    r1=0; r2=0; r3=0; r4=0; r5=0; r6=0; r7=0;
    walking=false; pancakes=0; stamina=100;
    U=false; D=false; R=false; L=false;
  }
  void display() {
    pushMatrix();
    translate(x, y);
    noStroke();
    fill(0,50);
    ellipse(0,17,30,20);
    stroke(0);
    strokeWeight(25);
    line(r1*10, r2*5, r1*10, -20 + r2*5);
    line(r1*-10, -r2*5, r1*10, r2*5);
    strokeWeight(16);
    line(r3*5, r4*2, r3*5 + r1*(-r6*3), 13 + r4*2 + r2*(-r6*3));
    line(r3*-5, r4*-2, r3*-5 + r1*(r6*3), 13 + r4*-2 + r2*(r6*3));
    strokeWeight(15);
    line(r1*20, -16 + r2*7, r1*25, -16 + r2*10);
    stroke(247,180,37);
    strokeWeight(13);
    line(r3*5, r4*2, r3*5 + r1*(-r6*3), 13 + r4*2 + r2*(-r6*3));
    line(r3*-5, r4*-2, r3*-5 + r1*(r6*3), 13 + r4*-2 + r2*(r6*3));
    stroke(255);
    strokeWeight(22);
    line(r1*10, r2*5, r1*10, -20 + r2*5);
    line(r1*-10, -r2*5, r1*10, r2*5);
    stroke(247,180,37);
    strokeWeight(13);
    line(r1*24, -16 + r2*9, r1*25, -16 + r2*10);
    if (d%360 != 0) {
      strokeWeight(11 + r5*11);
      if (r5*11 > 2) {
        stroke(255);
      } else {
        noStroke();
      }
      line(r1*10, r2*5, r1*10, -20 + r2*5);
    }
    popMatrix();
  }
}

class Carrot {
  float ang, sz;
  Carrot() {
    ang=0; sz=1;
  }
}

void ducklol(float x, float y, float r, float sz) {
  pushMatrix();
  translate(x, y);
  rotate(radians(r));
  scale(sz/400);
  stroke(0);
  strokeWeight(10);
  fill(0,0,0);
  ellipse(0,57,186,100);
  strokeWeight(176);
  line(0,0,0,267);
  stroke(255);
  strokeWeight(166);
  line(0,0,0,265);
  noStroke();
  fill(255,217,0);
  ellipse(0,57,186,100);
  fill(0);
  ellipse(-63,3,20,20);
  ellipse(63,3,20,20);
  noFill();
  stroke(0);
  strokeWeight(10);
  arc(0,38,182,67,radians(33),radians(146));
  popMatrix();
}

void game() {
  background(149,191,161);
  shake_time--;
  pushMatrix();
  translate(cam.x+300+shake, cam.y+400+shake);
  noStroke();
  fill(169,214,182);
  rect(0,0,2000,2000);
  for (Grass g : jurassic_grassusses) {
    g.display();
  }
  serve_pancakes(20,"back");
  dirt();
  if (ducks.y<30) {
    ducks.display();
    duck(ducks.x, ducks.y, ducks.d);
    carrot();
  } else {
    carrot();
    ducks.display();
    duck(ducks.x, ducks.y, ducks.d);
  }
  serve_pancakes(20,"front");
  pop();

  if (dist(ducks.x, ducks.y, 0, 30) < 80 + carrott.sz*30) {
    fill(0,50);
    rect(300, 550, 265, 40, 5);
    textSize(24);
    fill(0);
    text("\"E\" offer pancakes", 300, 550);
    if (keyDown(69)) {
      if (frameCount%20<1 && ducks.pancakes>0) {
        ducks.pancakes--;
        carrott.sz += 0.02;
        shake_time=30;
      }
    }
  }
  honk();
  noStroke();
  fill(255,153,0);
  pushMatrix();
  translate(300,400);
  rotate(-carrott.ang + PI);
  ellipse(0,84,10,10);
  ellipse(2,80,10,10);
  ellipse(-2,80,10,10);
  ellipse(0,89,5,5);
  ellipse(-6,77,5,5);
  ellipse(6,77,5,5);
  popMatrix();

  stroke(0);
  fill(185,231,235);
  rect(20,580,50+ducks.stamina,20);
  textSize(30);
  fill(0);
  text(ducks.pancakes,50,548);
  pancakecola(50,522);
  textSize(16);
  fill(0);
  text("STAMINA", 62+ducks.stamina,575);
  cam.x = lerp(cam.x, -ducks.x, 0.1);
  cam.y = lerp(cam.y, -ducks.y, 0.1);
  if (ducks.x<-1000 || ducks.x>1000 || ducks.y<-1000 || ducks.y>1000) {
    fill(0,50);
    noStroke();
    rect(300,300,601,601);
  }
  if (shake_time>0) {
    shake = random(-2,2);
  } else {
    shake=0;
  }
}

void menu() {
  background(123,86,245);
  textSize(50);
  fill(0);
  text("The",150,46);
  fill(255);
  text("The",150,48);
  textSize(103);
  fill(0);
  text("Duck",150,98);
  fill(255);
  text("Duck",150,100);
  textSize(103);
  fill(0);
  text("Game",150,168);
  fill(255);
  text("Game",150,170);
  textSize(190);
  fill(0);
  text("ðŸ¦†",350,118);
  fill(255);
  text("ðŸ¦†",350,120);
  textSize(20);
  fill(0);
  text("click duck to start",147,224);
  fill(255);
  text("click duck to start",147,226);
  textSize(25);
  fill(0);
  text("by Æ¬Ó¨Î£KÐŸÎ£Î£-top",101,571);
  fill(255);
  text("by Æ¬Ó¨Î£KÐŸÎ£Î£-top",101,573);
  pushMatrix();
  translate(310,301);
  rotate(radians(-34));
  if (dist(mouseX, mouseY, 310, 301) < 35) {
    scale(1.2);
    if (clicked) {
      if (scene==scene2b) {
        intro_timer=110;
        scene2b="how";
      }
    }
  } else {
    scale(1);
  }
  textSize(113);
  fill(0);
  text("?",0,-2);
  fill(255);
  text("?",0,0);
  popMatrix();

  pushMatrix();
  translate(300,450);
  // no drawing necessary here
  popMatrix();

  if (dist(mouseX, mouseY, 381, 407) < 75) {
    if (clicked) {
      if (scene==scene2b) {
        intro_timer=110;
        scene2b="game";
      }
    }
    pushMatrix();
    translate(385,414);
    rotate(radians(-30));
    stroke(0);
    strokeWeight(10);
    fill(0);
    ellipse(0,57,186,100);
    strokeWeight(176);
    line(0,0,0,267);
    stroke(255);
    strokeWeight(166);
    line(0,0,0,265);
    noStroke();
    fill(255,217,0);
    ellipse(0,57,186,100);
    fill(0);
    ellipse(-63,3,20,20);
    ellipse(63,3,20,20);
    noFill();
    stroke(0);
    strokeWeight(10);
    arc(0,38,182,67,radians(33),radians(146));
    popMatrix();
  } else {
    pushMatrix();
    translate(399,438);
    rotate(radians(-30));
    stroke(0);
    strokeWeight(10);
    fill(0);
    ellipse(0,57,186,100);
    strokeWeight(176);
    line(0,0,0,267);
    stroke(255);
    strokeWeight(166);
    line(0,0,0,265);
    noStroke();
    fill(255,217,0);
    ellipse(0,57,186,100);
    fill(0);
    ellipse(-63,3,20,20);
    ellipse(63,3,20,20);
    noFill();
    stroke(0);
    strokeWeight(10);
    arc(0,38,182,67,radians(33),radians(146));
    popMatrix();
  }
}

void how() {
  background(103,81,245);
  pushMatrix();
  translate(77,551);
  if (dist(mouseX, mouseY, 77, 551) < 40) {
    scale(1.2);
    if (clicked) {
      if (scene==scene2b) {
        intro_timer=110;
        scene2b="menu";
      }
    }
  } else {
    scale(1);
  }
  textSize(35);
  fill(0);
  text("Menu",0,-2);
  fill(255);
  text("Menu",0,0);
  textSize(120);
  text("â‡¦",-5,4);
  popMatrix();
  textSize(50);
  fill(255);
  text("how?",300,44);
  textSize(27);
  fill(255);
  text("1. Be duck\n\n2. Collect pancakes,\n3. Feed said pancakes to carrot,\n4. Watch carrot grow\n5. Repeat\n\n[W]\n[A][S][D]\nto move\n\n[space] to sprint",300,329);
  fill(255);
  textSize(15);
  text("the following steps are optional:",308,190);
}

// Helper functions

void dirt() {
  noStroke();
  for (int i=dirts.size()-1; i>=0; i--) {
    fill(181,145,103, dirts.get(i).opacity);
    ellipse(dirts.get(i).x, dirts.get(i).y, dirts.get(i).opacity/50, dirts.get(i).opacity/50);
    dirts.get(i).opacity -= 2;
    if (dirts.get(i).opacity < 0) {
      dirts.remove(i);
    }
  }
}

class DirtParticle {
  float x, y;
  float opacity;
  DirtParticle(float xx, float yy) {
    x=xx; y=yy; opacity=255;
  }
}

void dirt() {
  for (int i=dirts.size()-1; i>=0; i--) {
    DirtParticle p=dirts.get(i);
    fill(181,145,103,p.opacity);
    ellipse(p.x,p.y,p.opacity/50,p.opacity/50);
    p.opacity -= 2;
    if (p.opacity<0) {
      dirts.remove(i);
    }
  }
}

void duck(float x, float y, float d) {
  pushMatrix();
  translate(x,y);
  noStroke();
  fill(0,50);
  ellipse(0,17,30,20);
  stroke(0);
  strokeWeight(25);
  line(r1*10, r2*5, r1*10, -20 + r2*5);
  line(r1*-10, -r2*5, r1*10, r2*5);
  strokeWeight(16);
  line(r3*5, r4*2, r3*5 + r1*(-r6*3), 13 + r4*2 + r2*(-r6*3));
  line(r3*-5, r4*-2, r3*-5 + r1*(r6*3), 13 + r4*-2 + r2*(r6*3));
  strokeWeight(15);
  line(r1*20, -16 + r2*7, r1*25, -16 + r2*10);
  stroke(247,180,37);
  strokeWeight(13);
  line(r3*5, r4*2, r3*5 + r1*(-r6*3), 13 + r4*2 + r2*(-r6*3));
  line(r3*-5, r4*-2, r3*-5 + r1*(r6*3), 13 + r4*-2 + r2*(r6*3));
  stroke(255);
  strokeWeight(22);
  line(r1*10, r2*5, r1*10, -20 + r2*5);
  line(r1*-10, -r2*5, r1*10, r2*5);
  stroke(247,180,37);
  strokeWeight(13);
  line(r1*24, -16 + r2*9, r1*25, -16 + r2*10);
  if (d%360 != 0) {
    strokeWeight(11 + r5*11);
    if (r5*11 > 2) {
      stroke(255);
    } else {
      noStroke();
    }
    line(r1*10, r2*5, r1*10, -20 + r2*5);
  }
  popMatrix();
}

void honk() {
  r1 = sin(ducks.d);
  r2 = cos(ducks.d);
  r3 = sin(ducks.d + HALF_PI);
  r4 = cos(ducks.d + HALF_PI);
  r5 = sin(ducks.d + 1.5*PI);
  if (ducks.walking) {
    r6 = cos(PI/2 + frameCount*0.1);
    dirts.push(new DirtParticle(ducks.x + random(-10,10), ducks.y + random(10,20)));
    r7 = sin(ducks.d + HALF_PI);
  } else {
    r6 = lerp(r6, 0, 0.1);
  }
  // Handle movement based on keys
  if (keyDown(87)) { // W
    ducks.walking=true;
    ducks.y -= ducks.speed;
    ducks.U=true;
  } else if (keyDown(83)) { // S
    ducks.walking=true;
    ducks.y += ducks.speed;
    ducks.D=true;
  } else {
    ducks.walking=false;
  }
  if (keyDown(65)) { // A
    ducks.walking=true;
    ducks.x -= ducks.speed;
    ducks.L=true;
  }
  if (keyDown(68)) { // D
    ducks.walking=true;
    ducks.x += ducks.speed;
    ducks.R=true;
  }

  // Direction logic
  if (ducks.U && ducks.L) {
    ducks.d = lerpAngle(ducks.d, -PI, 0.1);
  } else if (ducks.U && ducks.R) {
    ducks.d = lerpAngle(ducks.d, PI/2, 0.1);
  } else if (ducks.D && ducks.L) {
    ducks.d = lerpAngle(ducks.d, -PI/2, 0.1);
  } else if (ducks.D && ducks.R) {
    ducks.d = lerpAngle(ducks.d, PI, 0.1);
  } else if (ducks.U) {
    ducks.d = lerpAngle(ducks.d, -PI/2, 0.1);
  } else if (ducks.D) {
    ducks.d = lerpAngle(ducks.d, 0, 0.1);
  } else if (ducks.L) {
    ducks.d = lerpAngle(ducks.d, -PI, 0.1);
  } else if (ducks.R) {
    ducks.d = lerpAngle(ducks.d, PI/2, 0.1);
  }

  // Sprint
  if (keyDown(32)) { // space
    if (ducks.stamina>1) {
      ducks.speed=4;
    } else {
      ducks.speed=2;
    }
    if (ducks.stamina>0) {
      ducks.stamina -= 0.2;
    }
  } else {
    ducks.speed=2;
    if (ducks.stamina<100) {
      ducks.stamina+=0.3;
    }
  }
}

// Utility function for angle lerp
float lerpAngle(float a, float b, float t) {
  float diff = b - a;
  while (diff > PI) { diff -= TWO_PI; }
  while (diff < -PI) { diff += TWO_PI; }
  return a + diff * t;
}

void pancake() {
  pushMatrix();
  translate(x,y);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  ellipse(0,-5,41,15);
  ellipse(0,-8,41,15);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  ellipse(0,-15,41,15);
  ellipse(0,-18,41,15);
  ellipse(0,-21,41,15);
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  fill(255,253,209);
  ellipse(0,-3,41,15);
  fill(219,175,134);
  ellipse(0,-5,41,15);
  fill(255,253,209);
  ellipse(0,-8,41,15);
  fill(219,175,134);
  ellipse(0,-10,41,15);
  fill(255,253,209);
  ellipse(0,-13,41,15);
  fill(219,175,134);
  ellipse(0,-15,41,15);
  fill(255,253,209);
  ellipse(0,-18,41,15);
  fill(219,175,134);
  ellipse(0,-21,41,15);
  fill(255,253,209);
  quad(-10,-22,0,-18,9,-22,0,-26);
  popMatrix();
}

// Pancakes collection display
void pancakecola(float x, float y) {
  pushMatrix();
  translate(x,y);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  for (int i=0; i<ducks.pancakes; i++) {
    pushMatrix();
    translate(0, -4*i);
    ellipse(0,-3,41,15);
    ellipse(0,-5,41,15);
    popMatrix();
  }
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  for (int i=0; i<ducks.pancakes; i++) {
    pushMatrix();
    translate(0, -4*i);
    fill(255,253,209);
    ellipse(0,-3,41,15);
    fill(219,175,134);
    ellipse(0,-5,41,15);
    fill(255,253,209);
    quad(-10,-7,0,-3,9,-7,0,-11);
    popMatrix();
  }
  popMatrix();
}

void serve_pancakes(int strv, String beef) {
  while (pankakes.size() < strv) {
    pankakes.push(new Pancake(random(-1000,1000), random(-1000,1000)));
  }
  for (int i=pankakes.size()-1; i>=0; i--) {
    Pancake p = pankakes.get(i);
    if (beef.equals("back")) {
      if (p.y < ducks.y + 13) {
        pancakes(p.x,p.y);
        if (dist(ducks.x, ducks.y, p.x,p.y) < 40) {
          ducks.pancakes++;
          pankakes.remove(i);
        }
      }
    } else if (beef.equals("front")) {
      if (p.y > ducks.y + 13) {
        pancakes(p.x,p.y);
        if (dist(ducks.x, ducks.y, p.x,p.y) < 40) {
          ducks.pancakes++;
          pankakes.remove(i);
        }
      }
    }
  }
}

class Pancake {
  float x,y;
  Pancake(float xx, float yy) {
    x=xx; y=yy;
  }
}

void pancakes(float x, float y) {
  pushMatrix();
  translate(x,y);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  ellipse(0,-5,41,15);
  ellipse(0,-8,41,15);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  ellipse(0,-15,41,15);
  ellipse(0,-18,41,15);
  ellipse(0,-21,41,15);
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  fill(255,253,209);
  ellipse(0,-3,41,15);
  fill(219,175,134);
  ellipse(0,-5,41,15);
  fill(255,253,209);
  ellipse(0,-8,41,15);
  fill(219,175,134);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  fill(255,253,209);
  quad(-10,-22,0,-18,9,-22,0,-26);
  popMatrix();
}

void pancake() {
  pushMatrix();
  translate(0,0);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  ellipse(0,-5,41,15);
  ellipse(0,-8,41,15);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  ellipse(0,-15,41,15);
  ellipse(0,-18,41,15);
  ellipse(0,-21,41,15);
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  fill(255,253,209);
  ellipse(0,-3,41,15);
  fill(219,175,134);
  ellipse(0,-5,41,15);
  fill(255,253,209);
  ellipse(0,-8,41,15);
  fill(219,175,134);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  fill(255,253,209);
  quad(-10,-22,0,-18,9,-22,0,-26);
  popMatrix();
}

void pancake() {
  pushMatrix();
  translate(0,0);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  ellipse(0,-5,41,15);
  ellipse(0,-8,41,15);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  ellipse(0,-15,41,15);
  ellipse(0,-18,41,15);
  ellipse(0,-21,41,15);
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  fill(255,253,209);
  ellipse(0,-3,41,15);
  fill(219,175,134);
  ellipse(0,-5,41,15);
  fill(255,253,209);
  ellipse(0,-8,41,15);
  fill(219,175,134);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  fill(255,253,209);
  quad(-10,-22,0,-18,9,-22,0,-26);
  popMatrix();
}

void pancake() {
  pushMatrix();
  translate(0,0);
  strokeWeight(3);
  stroke(0);
  ellipse(0,-1,50,10);
  ellipse(-8,0,35,18);
  ellipse(8,0,35,18);
  ellipse(0,-3,41,15);
  ellipse(0,-5,41,15);
  ellipse(0,-8,41,15);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  ellipse(0,-15,41,15);
  ellipse(0,-18,41,15);
  ellipse(0,-21,41,15);
  noStroke();
  fill(207,207,207);
  ellipse(0,0,50,15);
  ellipse(0,3,40,15);
  fill(255,253,209);
  ellipse(0,-3,41,15);
  fill(219,175,134);
  ellipse(0,-5,41,15);
  fill(255,253,209);
  ellipse(0,-8,41,15);
  fill(219,175,134);
  ellipse(0,-10,41,15);
  ellipse(0,-13,41,15);
  fill(255,253,209);
  quad(-10,-22,0,-18,9,-22,0,-26);
  popMatrix();
}

void setup() {
  size(600, 600);
  rectMode(CENTER);
  textFont(createFont("Courier"));
  textAlign(CENTER, CENTER);
}
 
  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>
